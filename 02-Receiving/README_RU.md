# Получение сообщений

## Проверка сообщений

![// Dear future self, keys in freezer because...](Keys.png)

В предыдущем уроке мы научились отправлять сообщения. Сейчас время научиться их получать. Синтаксис для этого в самом общем случае выглядит так:

`for(message <- channel){ // Тут мы что-то делаем}`

Кстати, строчки, которые начинаются с `//` называются комментариями. Они полезны только для разработчиков и не влияют на поведение программы. Тщательно прокомментированный код легче читать и понимать. Особенно, когда разбираешь старые программы.

## Коммуникационные события

![Pizza shop can receive messages on its channel.](pizza.png)

Следующий код отправляет сообщение на канал пиццерии, а пиццерия его получает. Пиццерия подтверждает получение сообщения через stdout.

[pizzaOrder](pizzaOrder.rho)

### Упражнение
Отправьте сообщение на другой канал, например `@"coffeShop"`. Выводится ли подтверждение? Остается ли что-либо в хранилище? 

![Let's hit up the coffee shop.](coffee.png)

### Упражнение
Помните, в ро всё происходит не по порядку, в котором написано, а одновременно. Код пиццерии будет работать так же хорошо, если мы пропишем поглощение сообщения вначале. Попробуйте поменять местами отправку и получение. 

## Завалы в хранилище
<!-- TODO I really wasn't sure where to put this part -->
Если вы сталкиваетесь с проблемами из-за того, что старые данные остаются в хранилище и вылезают в ненужный момент, то вам надо очистить пространство кортежей. Самый простой способ это сделать -- удалить директорию с данными, которая обычно называется`.rnode`
<!-- TODO I should write a script for this -->

Регулярно подчищать хранилище - утомительное занятие. Было бы лучше, что оно вообще не захламлялось. Мы можем сделать это, изменив самую первую строчку кода со словом `new`.

Вместо старого подхода
```
new stdout(`rho:io:stdout`) in {
  @"world"!("Welcome to RChain")
}
```

Попробуем следующее
```
new world, stdout(`rho:io:stdout`) in {
  world!("Welcome to RChain") // No more @ or " "
}
```
Мы обсудим, как это всё работает в уроке по Неподделаемым именам. Пока же нам достаточно того, что кортеж не захламляется.

## Получение перед отправкой

![Rather than the message appearing first, then someone receiving it, Greg is trying to receive first. Hopefully someone will send him a message so he can have a comm event.](lookingForMessages.png)

Когда на канале возникают отправка и получение, то такой случай называется коммуникационным событием или "комм-событием" для краткости.

В отличие от обычной почти, где сообщение нужно сначала отправить, а только <em>затем</em> его можно получить, в ро эти два события могут происходить в любой последовательности или одновременно. Когда отправка и получение возникают на канале, то происходит "комм-событие". 



## Контракты

![The poor chef is too busy making sure he can receive orders to take care of his pizza.](pizzaBurning.png)

Наш пример с пиццерией служит хорошей иллюстрацией комм-событий. Однако врядли пиццерия будет вручную создавать новое событие получения для каждого заказа, когда каждый новый заказ будет поглощать его из хранилища.

К счастью, у нас есть возможность разместить код один раз, а затем выполнять его <em>каждый</em> раз, когда мы получаем сообщение. Такой прием называют "контрактом". Давайте взглянем на код для кофейни, который гораздо лучше, чем код для пиццерии.

[coffeeShop.rho](coffeeShop.rho)


### Упражнение
Закажите в кофейне третий напиток

### Упражнение
Измените сообщение с подтверждением

### Тест
Что обычно происходит в первую очередь?
- [ ] Отправка, потому что так обычно происходит с письмами.
- [ ] Получение, так как в таком случае код исполняется быстрее.
- [x] И отправка, и получение могут быть первыми, или же они могут произойти одновременно.
- [ ] Ни то, ни другое. Сразу происходит коммуникационное событие.

### Упражнение
Сейчас имя канала просто `@"coffeeShop"`. Измените его на название вашей любимой кофейни. И заодно имените код, используя `new` новым образом, как мы только что научились. Т.е. без `@` и кавычек.



## Персистентный For
В ро есть два различных систаксических стиля, при помощи которых можно добиться персистентного поведения кода.Только что мы познакомились с `contract`. Это один из стилей. Но есть и другой. Следующие куски кода задают одинаковое поведение.

```rholang
contract @"coffeeShop"(order) = {
```

```rholang
for(order <= @"coffeeShop") {
```
Обратите внимание на отличие от обычного выражения с `for`. Здесь используется двойная стрелка`<=` вместо одинарной `<-`. Различия между персистентным `for` и контрактом возникают только в контексте блокчейна. Пока же мы можем считать, что эти два выражения ведут себя одинаково.

### Упражнение
Пиццерии тоже нужен контракт, похожий на то, что есть у кофейни. Давайте его напишем, но будем использовать персистентный for вместо контракта. Попробуйте написать его полностью с нуля, чтобы лучше запомнить синтаксис.
<!-- Подсмотреть решение можно тут
[persistentPizzaShop.rho](persistentPizzaShop.rho), -->


Что из этого ведёт себя не так, как два других выражения?
- [x] `for (a <- b){}`
- [ ] `contract b(a) = {}`
- [ ] `for (a <= b){}`

Что нужно отправить, чтобы создать комм-событие с `for (message <- @"grandmasSnapChat"){Nil}`?
- [ ] `grandmasSnapChat!("Hi Grandma")`
- [x] `@"grandmasSnapChat"!("Glad you're snapping Grandma")`
- [ ] `for("Here's a snap for you g'ma" <- @"grandmasSnapChat")`
