# 持续发送与窥探

## 为什么要重复发送？

![This radio navigation aid helps airplanes navigate by broadcasting the same message over and over](broadcasting.png)

我们的披萨和咖啡店都可以在同一个复用通道中接收消息。我们使用一个持续的`for (msg <= chan){...}`或者一个合约`contract chan(msg){...}`来达成这一目的。

空中交通管制塔楼可能会乐于做刚好相反的事——不停地发送相同的消息。塔楼中的控制者希望记录同时包含天气和跑道信息的消息，并且提供给所有需要的飞行员。类似披萨店， 他们很繁忙，不会费力地在每次飞行员需要时都不停地发送信息。



## 持续发送的语法

控制塔需要在代码上做较小的调整，以使得发送操作能够持续。他们会使用`!!`而非单个`!`。

[persistentSend.rho](persistentSend.rho)

请自行确认一下，原先发送的消息是否仍然在元组空间内。

### 练习
注意上述代码，第二名飞行员同样能够接收到信息。发送仍在持续。

对了，你注意到了吗？当我们实际上并不使用`stdout`时，我们不需要`new stdout(...) in {}`

`for (x <- y) {Nil} | y!!(Nil)`中有多少次通信事件发生？
- [x] `1`
- [ ] `很多次`
- [ ] `0`


## 二次检查消息

正如我们刚才展示的，持续性发送和接收非常有用。但是，普通的发送和接收也同样足够好了。设想这样的场景：我将一个字母发送给祖母，她接收到了这个消息。

[grandma.rho](grandma.rho)

现在我们设想：我想要二次检查我是否给她发送了正确的时间。我可以简单地取出这条消息，但这样一来她就没法读取这个消息了。

### 练习
依据你所知道的，你可以通过获取这个消息，自行检查它，再将它发送回旧的通道，以达到我们的目的。

请自行尝试上面的方案。答案已列在下面。


`for (x <= y) {Nil} | y!!(Nil)`会产生多少个通信事件？
- [ ] `1`
- [x] `很多个`
- [ ] `0`


## 答案

[grandmaCheck.rho](grandmaCheck.rho)


## 窥探语法

![Maybe I'll just peak at Grandma's letter through the envelope.](letterPeak.png)


rholang以后会为观察通道内变量提供一个特殊的语法。目前我们还不能使用它，但是下面会展示给你看这个语法的用法。我们将使用`<!`操作符来"窥探"一个通道内的消息。

[peek.rho](peek.rho)

如果你使用过excel的宏，或者excel，你应该对如何在不取出数据的情况下访问它感到非常熟悉。把它当做`for (value <! A1) { ... }`。



下列哪一个语法是用于窥探一个消息的？
- [x] `for (x <! y){...}`
- [ ] `for (x <= y){...}`
- [ ] `x!!(y)`



`for (x <! y) {Nil} | y!!(Nil)`会产生多少个通信事件？
- [x] `1`
- [ ] `许多`
- [ ] `0`
